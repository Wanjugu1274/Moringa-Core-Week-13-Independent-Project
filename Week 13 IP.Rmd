---
title: "Moringa Week 13 Independent Project"
author: "Agnes Githiri"
date: '2022-06-04'
output:
  html_document:
    df_print: paged
  pdf_document: default
---


# 1) Defining the question
## a) Specifying the question


## b) Defining the Metric of Success
The project will be considered successful when we build clustering models with 
high precision in clustering the different customer groups


## c) Understanding the context
ira Plastinina is a Russian brand that is sold through a defunct chain of retail
stores in Russia, Ukraine, Kazakhstan, Belarus, China, Philippines, and Armenia.
The brand’s Sales and Marketing team would like to understand their customer’s 
behavior from data that they have collected over the past year. More 
specifically, they would like to learn the characteristics of customer groups.


## d) Recording the experimental design


## e) Data Relevance
The dataset for this Independent project can be found here 
[http://bit.ly/EcommerceCustomersDataset (Links to an external site.)].  

The dataset consists of 10 numerical and 8 categorical attributes. 
The 'Revenue' attribute can be used as the class label.

"Administrative", "Administrative Duration", "Informational", 
"Informational Duration", "Product Related" and "Product Related Duration" 
represents the number of different types of pages visited by the visitor in that
session and total time spent in each of these page categories. The values of 
these features are derived from the URL information of the pages visited by the
user and updated in real-time when a user takes an action, e.g. moving from one
page to another. 

The "Bounce Rate", "Exit Rate" and "Page Value" features represent the metrics 
measured by "Google Analytics" for each page in the e-commerce site. 
The value of the "Bounce Rate" feature for a web page refers to the percentage 
of visitors who enter the site from that page and then leave ("bounce") without
triggering any other requests to the analytics server during that session. 

The value of the "Exit Rate" feature for a specific web page is calculated as 
for all pageviews to the page, the percentage that was the last in the session.
The "Page Value" feature represents the average value for a web page that a user
visited before completing an e-commerce transaction. 

The "Special Day" feature indicates the closeness of the site visiting time to 
a specific special day (e.g. Mother’s Day, Valentine's Day) in which the 
sessions are more likely to be finalized with the transaction. The value of this
attribute is determined by considering the dynamics of e-commerce such as the
duration between the order date and delivery date. For example, for Valentina’s 
day, this value takes a nonzero value between February 2 and February 12, zero
before and after this date unless it is close to another special day, and its 
maximum value of 1 on February 8. 

The dataset also includes the operating system, browser, region, traffic type,
visitor type as returning or new visitor, a Boolean value indicating whether the
date of the visit is weekend, and month of the year.


# 2) Loading the Dataset
```{r}
# Load the dataset using fread() function and instantiate it
library(data.table)
Customers <- fread('http://bit.ly/EcommerceCustomersDataset')
```

# 3) Reading the data
```{r}
# Preview the top 6 records of the dataset
head(Customers)
```

```{r}
# Checking the size of the dataset
dim(Customers)

# The dataset has 12330 rows and 18 columns
```

```{r}
# Checking the data type of each variable using sapply() function
sapply(Customers, class)
```
'OperatingSystems', 'Browser', 'Region', and 'traffictype' are categorical 
variables even though they have numeric values. That will be changed in data
cleaning.


# 4) Data Cleaning
```{r}
# Standardizing the column names by adding separators 
colnames(Customers) <- c('Administrative', 'Administrative_Duration',
                         'Informational', 'Informational_Duration',
                         'Product_Related', 'Product_Related_Duration',
                         'Bounce_Rates', 'Exit_Rates','Page_Values',
                         'Special_Day', 'Month', 'Operating_Systems', 'Browser',
                         'Region','Traffic_Type', 'Visitor_Type', 'Weekend', 
                         'Revenue')


# Printing the new data frame
print(Customers)
```

```{r}
# Check for duplicates in the data
anyDuplicated(Customers)
```
The data has 159 duplicated rows.


```{r}
# Dropping the duplicated data
Customers<- Customers[!duplicated(Customers)]

#Checking if the duplicates have been dropped
anyDuplicated(Customers)
```
The data no longer has duplicates.


```{r}
# Checking for missing values
colSums(is.na(Customers))
```
Some rows have missing values as seen in the output above. Those will be dropped.


```{r}
# Dropping the missing values
Customers <-  na.omit(Customers)

# Checking to see if the missing values have been dropped
colSums(is.na(Customers))
```
All the missing values have been dropped.


```{r}
# checking for outliers in the 'administrative' column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Administrative, main="Boxplot for Administrative", 
        xlab = "Administrative", ylab = "Value", boxwex=0.4, cex.main=2,
        cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_administrative <- boxplot.stats(Customers$Administrative)$out
mtext(paste("Outliers: ", paste(length(outlier_administrative), 
                                collapse=", ")), cex=1)
```
The Administrative column has 404 outliers


```{r}
# Checking for outliers in the 'administrative_duration' column by plotting a
# boxplot

options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Administrative_Duration, main="Boxplot for Administrative Duration"
        , xlab = "Administrative Duration", ylab = "Value", boxwex=0.4,
        cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_administrative_duration <- boxplot.stats(Customers$Administrative_Duration)$out
mtext(paste("Outliers: ", paste(length(outlier_administrative_duration), 
                                collapse=", ")), cex=1)
```
The Administrative duration column has 1147 outliers.


```{r}
# Checking for outliers in the informational column 
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Informational, main="Boxplot for Informational",
        xlab = "Informational", ylab = "Value", boxwex=0.4, cex.main=2, 
        cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_informational <- boxplot.stats(Customers$Informational)$out
mtext(paste("Outliers: ", paste(length(outlier_informational), 
                                collapse=", ")), cex=1)
```
The Informational column has 2630 outliers.


```{r}
# Checking for outliers in the informational duration column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Informational_Duration, main="Boxplot for Informational Duration",
        xlab = "Informational Duration", ylab = "Value", boxwex=0.4, 
        cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_informational_duration <- boxplot.stats(Customers$Informational_Duration)$out
mtext(paste("Outliers: ", paste(length(outlier_administrative_duration),
                                collapse=", ")), cex=1)
```
The informational Duration column has 1147 outliers


```{r}
# Checking for outliers in the product_related column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Product_Related, main="Boxplot for Product Related", 
        xlab = "Product related", ylab = "Value", boxwex=0.4, cex.main=2, 
        cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_productrelated <- boxplot.stats(Customers$Product_Related)$out
mtext(paste("Outliers: ", paste(length(outlier_productrelated), collapse=", ")), cex=1)
```
The product related column has 1007 outliers


```{r}
# Checking for outliers in the product related duration column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Product_Related_Duration,
        main="Boxplot for Product Related Duration", 
        xlab = "Product related duration", ylab = "Value", boxwex=0.4, 
        cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the number of outliers in the column
outlier_productrelated_duration <- boxplot.stats(Customers$Product_Related_Duration)$out
mtext(paste("Outliers: ", paste(length(outlier_productrelated_duration), 
                                collapse=", ")), cex=1)
```
The product related duration column has 951 outliers


```{r}
# Checking for outliers in the bounce rates column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Bounce_Rates, main="Boxplot for Bounce Rates", xlab = "Bounce rates", 
        ylab = "Value", boxwex=0.4, cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_bouncerates <- boxplot.stats(Customers$Bounce_Rates)$out
mtext(paste("Outliers: ", paste(length(outlier_bouncerates), 
                                collapse=", ")), cex=1)
```
The bounce rates column has 1431 outliers


```{r}
# Checking for outliers in the exit rates column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Exit_Rates, main="Boxplot for Exit Rates", xlab = "Exit Rates",
        ylab = "Value", boxwex=0.4, cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_exitrates <- boxplot.stats(Customers$Exit_Rates)$out
mtext(paste("Outliers: ", paste(length(outlier_exitrates), collapse=", ")), cex=1)
```
The exit rates column has 1327 outliers.


```{r}
# Checking for outliers in the page values column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Page_Values, main="Boxplot for Page Values", 
        xlab = "Page values",
        ylab = "Value", boxwex=0.4, cex.main=2, cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_pagevalues <- boxplot.stats(Customers$Page_Values)$out
mtext(paste("Outliers: ", paste(length(outlier_pagevalues), collapse=", ")), 
      cex=1)
```
The page values column hs 2730 outliers.


```{r}
# Checking for outliers in the special day column by plotting a boxplot
options(repr.plot.width = 10, repr.plot.height = 8)

boxplot(Customers$Special_Day, main="Boxplot for Special Day", 
        xlab = "Special day", ylab = "Value", boxwex=0.4, cex.main=2,
        cex.lab=1.5, cex.axis=1.2)

# Displaying the total number of outliers in the column
outlier_specialday <- boxplot.stats(Customers$Special_Day)$out
mtext(paste("Outliers: ", paste(length(outlier_specialday), collapse=", ")), cex=1)
```
The special day column has 1249 outliers.


```{r}
# Check for anomalies in the Month column 

print(unique(Customers$Month))
```
There are 10 unique values and no anomalies in the Month column


```{r}
# Check for anomalies in the operating systems column

print(unique(Customers$Operating_Systems))
```
There are 8 unique values and no anomalies in the operating systems column


```{r}
# Check for anomalies in the browser column
print(unique(Customers$Browser))
```
There are 13 unique values and no anomalies in the browser column.


```{r}
# Check for anomalies in the region column  
print(unique(Customers$Region))
```
There are 9 unique values and no anomalies in the region column.


```{r}
# Check for anomalies in the traffic type column
print(unique(Customers$Traffic_Type))
```
There are 20 unique values and no anomalies in the traffic type column.


```{r}
# Check for anomalies in the visitor type column
print(unique(Customers$Visitor_Type))
```


```{r}
# Find the number of rows with Other as the visitor type
sum(Customers$Visitor_Type == 'Other')
```
We'll drop the records with 'Other' as the visitor type to remain with the two classes


```{r}
# Dropping 'Other' from the data
Customers <- Customers[!(Customers$Visitor_Type =="Other")]
```


```{r}
# Check for anomalies in the weekend column 
print(unique(Customers$Weekend))
```
There are 2 unique values and no anomalies in the weekend column


```{r}
# Change the data types of 'operating systems', 'browser', 'region' and
# 'traffictype' columns to 'factor'
Customers <- transform(Customers, Operating_Systems=as.factor(Operating_Systems), 
                  Browser=as.factor(Browser), Region=as.factor(Region), 
                  Traffic_Type=as.factor(Traffic_Type))

```



```{r}
# check the shape of the dataframe after cleaning
dim(Customers)
```


# 5) Univariate Analysis
Univariate analysis will help us gain insights on the general characteristics 
of the individual variables in the dataset.

## 5.1) Numerical variables
Measures of central tendency and measures of dispersion

```{r}
# Check the numerical variables in the dataframe
num_col <- unlist(lapply(Customers, is.numeric))

# Create a subset that contains the numerical variables
Cust_num <- subset(Customers, select=num_col)

# Display the numerical columns
print(Cust_num)
```


```{r}
# compute the measures of central tendancy and the measures of dispersion of the
# numerical variables and contain them in a dataframe

library(modeest)
library(moments)
stats <- data.frame(
  Mean = apply(Cust_num, 2, mean), 
  Median = apply(Cust_num, 2, median), 
  Mode = apply(Cust_num, 2, mfv), 
  Min = apply(Cust_num, 2, min),  
  Max = apply(Cust_num, 2, max),    
  Variance= apply(Cust_num, 2, var),  
  Std = apply(Cust_num, 2, sd),
  Skewness = apply(Cust_num, 2, skewness), 
  Kurtosis = apply(Cust_num, 2, kurtosis))
  

# Round off the values to 2 decimal places and display the dataframe
stats <- round(stats, 2)
stats

```


```{r}
# Plot a histogram to visualize the distribution of values in administrative column
hist(Customers$Administrative)
```


```{r}
# plot a histogram to visualize the distribution of values in
# administrative duration column
hist(Customers$Administrative_Duration)
```


```{r}
# Plot a histogram to visualize the distribution of values in informational column
hist(Customers$Informational)
```


```{r}
# plot a histogram to visualize the distribution of values in 
#  informational duration column
hist(Customers$Informational_Duration)
```


```{r}
# Plot a histogram to visualize the distribution of values in product related column
hist(Customers$Product_Related)
```


```{r}
# Plot a histogram to visualize the distribution of values in product
# related duration column
hist(Customers$Product_Related_Duration)
```


```{r}
# Plot a histogram to visualize the distribution of values in bounce rates column
hist(Customers$Bounce_Rates)
```


```{r}
# Plot a histogram to visualize the distribution of values in exit rates column
hist(Customers$Exit_Rates)
```


```{r}
# Plot a histogram to visualize the distribution of values in page values column
hist(Customers$Page_Values)
```


```{r}
# Plot a histogram to visualize the distribution of values in special day column
hist(Customers$Special_Day)
```



# 5.2) Categorical Variables
```{r}
library(ggplot2)
ggplot(data = Customers, aes(x = "", y = Visitor_Type, fill = Visitor_Type)) + 
  geom_bar(stat = "identity") +  coord_polar("y")
main = 'Pie Chart for Visitor Type' 
```

```{r}
library(ggplot2)
ggplot(data = Customers, aes(x = "", y = Weekend, fill = Weekend)) + 
  geom_bar(stat = "identity") +  coord_polar("y")
main = 'Pie Chart for Weekend'
```


```{r}
library(ggplot2)
ggplot(data = Customers, aes(x = "", y = Revenue, fill = Revenue)) + 
  geom_bar(stat = "identity") +  coord_polar("y")
main = 'Pie Chart for Revenue'
```


```{r}
# Plot a bar chart to visualize the proportion of values in traffic type column
library(janitor)
ggplot(Customers, aes(Traffic_Type)) + 
        geom_bar(aes(y = (..count..)/sum(..count..)), fill = "#FF6666") + 
        scale_y_continuous(labels=scales::percent) +
        labs(title= 'Proportions of Traffic Types', x='Traffic Type',
             y= "Proportion") + 
        theme(axis.title = element_text(size = 18),
              axis.text = element_text(size=16),
              plot.title = element_text(hjust = 0.5, size = 24))

# Create a frequency table to get the actual figures of frequencies of parts of 
# the month using tabyl function
tabyl(Customers$Traffic_Type, sort = TRUE)
```


```{r}
# Plot a bar chart to visualize the proportion of values in the region column
library(janitor)
ggplot(Customers, aes(Region)) + 
        geom_bar(aes(y = (..count..)/sum(..count..)), fill = "#FF6666") + 
        scale_y_continuous(labels=scales::percent) +
        labs(title= 'Proportions of Regions', x='Region', y="Proportion") + 
        theme(axis.title = element_text(size = 18),
              axis.text = element_text(size=16),
              plot.title = element_text(hjust = 0.5, size = 24))

# create a frequency table to get the actual figures of frequencies of parts of
# the month using tabyl function
tabyl(Customers$Region, sort = TRUE)
```


```{r}
# Plot a bar chart to visualize the proportion of values in browser column
library(janitor)
ggplot(Customers, aes(Browser)) + 
        geom_bar(aes(y = (..count..)/sum(..count..)), fill = "#FF6666") + 
        scale_y_continuous(labels=scales::percent) +
        labs(title= 'Proportions of Browsers', x= 'Browser', y= "Proportion") + 
        theme(axis.title = element_text(size = 18),
              axis.text = element_text(size=16),
              plot.title = element_text(hjust = 0.5, size = 24))

# create a frequency table to get the actual figures of frequencies of parts of 
# the month using tabyl function
tabyl(Customers$Browser, sort = TRUE)
```


```{r}
# Plot a bar chart to visualize the proportion of values in operating systems column
library(janitor)
ggplot(Customers, aes(Operating_Systems)) + 
        geom_bar(aes(y = (..count..)/sum(..count..)), fill = "#FF6666") + 
        scale_y_continuous(labels=scales::percent) +
        labs(title= 'Proportions of Operating Systems', x= 'Operating Systems',
             y= "Proportion") + 
        theme(axis.title = element_text(size = 18),
              axis.text = element_text(size=16),
              plot.title = element_text(hjust = 0.5, size = 24))

# create a frequency table to get the actual figures of frequencies of parts of 
# the month using tabyl function
tabyl(Customers$Operating_Systems, sort = TRUE)
```
Many individuals used the internet beginning to mid month than the end of the month

```{r}
# Plot a bar chart to visualize the proportion of values in the month column
library(janitor)
ggplot(Customers, aes(Month)) + 
        geom_bar(aes(y = (..count..)/sum(..count..)), fill = "#FF6666") + 
        scale_y_continuous(labels=scales::percent) +
        labs(title= 'Proportions of Months', x = 'Month', y = "Proportion") + 
        theme(axis.title = element_text(size = 18),
              axis.text = element_text(size=16),
              plot.title = element_text(hjust = 0.5, size = 24))

# create a frequency table to get the actual figures of frequencies of parts of 
# the month using tabyl function
tabyl(Customers$Month, sort = TRUE)
```


*OBSERVATIONS*

1) Most of the visitors are returning visitors
2) Most of the visitors visited the site on weekdays
3) Majority of the visitors do not generate revenue
4) The region with the most number of visitors is region 1
5) The most common traffic type is type 2
6) The most common browser is browser 2
7) The most common operating system is operating system 2
8) The month of May had the most number of visitors


# 6) Bivariate Analysis
This analysis will help us establish the relationship between the variables

```{r}
# compute the correlation coefficients between the numerical variables
library(ggcorrplot)
corr <- cor(Cust_num)

# Plot a heat map to visualize correlations
options(repr.plot.height = 20, repr.plot.width = 50)

ggcorrplot(round(corr, 2) ,lab = T,type = 'lower')
```


```{r}
# plot pair plots to view the distribution of the values of the variables
options(repr.plot.height = 20, repr.plot.width = 20)
pairs(Cust_num )
```
There is a very strong positive correlation between:
Bounce rates and exit rates
Product related site visits and product related duration

There is a strong positive correlation between:
Administrative site visits and administrative duration
Informational site visits and informational duration

There are weak correlations between the rest of the variables

```{r}
# Find the means of administrative duration, informational duration, product 
# related duration, page values, exit rates, and bounce rates per month 
library(dplyr)
month_stats <- Customers %>% select(Month, Administrative_Duration, 
                                    Informational_Duration, 
                                    Product_Related_Duration, Page_Values, 
                                    Exit_Rates, Bounce_Rates) %>% group_by(Month)%>%summarise_all(mean) 
month_stats
```


```{r}
# Find the means of administrative_duration, informational_duration, product 
# related_duration, page values, exit rates, and bounce rates per region
library(dplyr)
region_stats <- Customers %>% select(Region, Administrative_Duration, 
                                     Informational_Duration, 
                                     Product_Related_Duration, Page_Values, 
                                     Exit_Rates, Bounce_Rates)%>% group_by(Region)%>%summarise_all(mean) 
region_stats
```
1) Visitors from region 8 spent the most time and visitors from region 6 spent
the least time on administrative sites compared to the visitors from the other
regions
2) Visitors from region 1 spent the most time and visitors from region 9 spent
the least time on informational sites compared to the visitors from the other 
regions
3) Visitors from region 1 spent the most time and visitors from region 6 spent 
the least time on product related sites compared to the visitors from the other
regions

```{r}
# Find the means of administrative_duration, informational_duration, product 
# related_duration, page values, exit rates, and bounce rates per browser
library(dplyr)
browser_stats <- Customers %>% select(Browser, Administrative_Duration, 
                                 Informational_Duration, 
                                 Product_Related_Duration, Page_Values, 
                                 Exit_Rates, Bounce_Rates)%>% group_by(Browser)%>%summarise_all(mean) 
browser_stats
```


```{r}
# Find the means of administrative_duration, informational_duration, product 
# related_duration, page values, exit rates, and bounce rates per operating 
# systems
library(dplyr)
OS_stats <- Customers %>% select(Operating_Systems, Administrative_Duration, 
                                 Informational_Duration, 
                                 Product_Related_Duration, Page_Values, Exit_Rates, Bounce_Rates)%>% group_by(Operating_Systems)%>%summarise_all(mean) 
OS_stats
```


```{r}
# Find the means of administrative_duration, informational_duration, product 
# related duration, exit rates, and bounce rates per visitor type 
library(dplyr)
Visitor_Type_stats <- Customers %>% select(Visitor_Type, Administrative_Duration,
                                           Informational_Duration, 
                                           Product_Related_Duration, Page_Values,
                                           Exit_Rates, Bounce_Rates)%>% group_by(Visitor_Type)%>%summarise_all(mean) 
Visitor_Type_stats
```
1) New visitors in administrative sites spend more time in the sites than 
returning visitors do.

2) The average page values were higher for the new visitors than for the 
returning visitors.

3) Returning visitors in informational sites and product related sites spend 
more time in the sites than new visitors do.

4) The exit rates and bounce rates of returning visitors are higher than the 
new visitors.

```{r}
# Find the means of administrative_duration, informational_duration, product 
# related duration, exit rates, and bounce rates per revenue 
library(dplyr)
Revenue_stats <- Customers %>% select(Revenue, Administrative_Duration,
                                           Informational_Duration, 
                                           Product_Related_Duration, Page_Values,
                                           Exit_Rates, Bounce_Rates)%>% group_by(Revenue)%>%summarise_all(mean) 
Revenue_stats
```
1) Visitors that generate revenue spend more time in administrative, 
informational and product related sites than visitors that don't.

2) The average page values were higher for visitors that generate revenue than
for those that didn't.

3) The average exit rates and bounce rates of visitors that do not generate 
revenue visitors that do.


```{r}
# Find the means of administrative_duration, informational_duration, product 
# related duration, exit rates, and bounce rates per weekend 
library(dplyr)
Weekend_stats <- Customers %>% select(Weekend, Administrative_Duration,
                                           Informational_Duration, 
                                           Product_Related_Duration, Page_Values,
                                           Exit_Rates, Bounce_Rates)%>% group_by(Weekend)%>%summarise_all(mean) 
Weekend_stats
```


1) Visitors that visit administrative, informational and product related sites
over the weekends spend more time in the sites than weekday visitors.

2) The average page values are higher on the weekends than on the weekdays.

3)The exit rates and bounce rates of the weekend visitors are lower than the 
weekday visitors.



# 7) Implementing the solution
K-Means clustering

```{r}
# Pre-processing the dataset

# Remove the class label ('revenue') from the dataset since we are doing 
# unsupervised learning
Customers_model <- Customers[, 1:17]

# Change the 'weekend' column's data type to 'factor'
Customers_model$Weekend <- as.factor(Customers$Weekend)

# One-hot encode the categorical variables
# Loading the library for the dummyVars() function
library(caret)
dummy <- dummyVars("~ .", "Month + Operating_Systems + Browser + Region + 
                   Traffic_Type + Visitor_Type + Weekend", data=Customers_model)
encoded <- data.frame(predict(dummy, newdata = Customers_model))
Customers_model <- cbind(Customers_model[ , 1:10], encoded)

# Normalize the values 
normal <-function(x) { (x -min(x))/(max(x)-min(x))}
Cust_norm <- as.data.frame(lapply(Customers_model, normal))

# Preview the top six records
head(Cust_norm)
```

```{r}
# Use silhouette method to find the optimal number of clusters
library(NbClust)
library(factoextra)
set.seed(25)
fviz_nbclust(Cust_norm, FUN = kmeans, method = "silhouette")
```



```{r}
# Apply the K-means clustering algorithm with no. of centroids (k)= 4
Result<- kmeans(Cust_norm, 2, nstart = 25) 

# check the number of records in each cluster
Result$size
```


```{r}
# View the cluster center data points by each attribute
Result$centers
```


```{r}
# Get the cluster vector that shows the cluster where each record falls
Result$cluster
```


```{r}
# Visualize the clusters
fviz_cluster(Result, data = Cust_norm)
```


```{r}
# Check the distribution of the classes revenue in the different classes
table(Result$cluster, Customers$Revenue)
```


# 8) Challenging the solution
Hierarchical clustering
```{r}
# Use the dist() function to compute the Euclidean distance between observations, 
# d will be the first argument in the hclust() function dissimilarity matrix

d <- dist(Cust_norm, method = "euclidean") # using the normalized data instead of scaling the data

```


```{r}
# Perform hierarchical clustering using the Ward's method

res.hc <- hclust(d, method = "ward.D2" )
```


```{r}
# Plot the obtained dendrogram
options(repr.plot.width = 15, repr.plot.height = 8)

plot(res.hc, cex = 0.6, hang = -1)
```
One cluster has more records than the other one.

```{r}
# Find the number of records in each cluster 
cut <- cutree(res.hc, k = 2)
table (cut)
```


```{r}
# Check the distribution of the classes ('revenue') in the different classes
table(cut, Customers$Revenue)
```


# Conclusions

Both the hierarchical and K-Means clustering models failed to cluster the 
revenue generating visitors correctly. This could be attributed to the major
class imbalance in the dataset. Nonetheless, the hierarchical clustering model
performed better than the K-Means model.


# Recommendations

Dimensionality reduction should be done in order to improve the performance 
of the models